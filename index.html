<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Аудио Транскрибатор</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .transcription-text { white-space: pre-wrap; }
    .loader {
      border-top-color: #3498db;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-slate-900 text-slate-100 flex items-center justify-center min-h-screen font-sans">
  <div id="root"></div>

  <!-- React и Babel CDN -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Google GenAI SDK -->
  <script type="module">
    import { GoogleGenAI } from "https://esm.run/@google/genai";
    window.GoogleGenAI = GoogleGenAI;
  </script>

  <!-- Код приложения React -->
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- СЕРВИСНЫЙ СЛОЙ ДЛЯ GEMINI API ---

    const uploadFileService = async (apiKey, file) => {
      const ai = new window.GoogleGenAI({ apiKey });
      const result = await ai.files.upload({ file });
      // ИСПРАВЛЕНО: Возвращаем весь объект result, так как он и является метаданными файла.
      return result;
    };

    const transcribeAudioFileService = async (apiKey, file) => {
      const ai = new window.GoogleGenAI({ apiKey });
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: [
            {
                fileData: {
                    mimeType: file.mimeType,
                    fileUri: file.uri,
                },
            },
            { text: "Transcribe this audio." }
        ],
      });
      return response.text;
    };
    
    const startLiveTranscriptionService = async (apiKey, onTranscriptionUpdate, onError) => {
        const ai = new window.GoogleGenAI({ apiKey });

        const session = await ai.live.connect({
            model: 'gemini-2.5-flash-native-audio-preview-09-2025',
            callbacks: {
                onmessage: (message) => {
                    if (message.serverContent?.inputTranscription) {
                        const text = message.serverContent.inputTranscription.text;
                        onTranscriptionUpdate(text, false);
                    }
                    if (message.serverContent?.turnComplete) {
                        onTranscriptionUpdate('', true); 
                    }
                },
                onerror: (e) => {
                    console.error('Live session error:', e);
                    onError("Ошибка сессии. Проверьте консоль.");
                },
                onclose: () => {
                    console.log('Live session closed.');
                },
            },
            config: {
                inputAudioTranscription: {},
            },
        });
        return session;
    };


    // --- UI КОМПОНЕНТЫ ---

    const ApiKeyInput = ({ onApiKeySubmit }) => {
      const [apiKey, setApiKey] = useState("");

      const handleSubmit = (e) => {
        e.preventDefault();
        if (apiKey.trim()) {
          onApiKeySubmit(apiKey.trim());
        }
      };

      return (
        <div className="w-full max-w-md p-8 space-y-6 bg-slate-800 rounded-lg shadow-xl">
          <div className="text-center">
            <h1 className="text-3xl font-bold text-white">API Ключ</h1>
            <p className="mt-2 text-slate-400">Введите ваш API ключ от Google AI Studio.</p>
          </div>
          <form onSubmit={handleSubmit} className="space-y-6">
            <input
              type="password"
              value={apiKey}
              onChange={(e) => setApiKey(e.target.value)}
              placeholder="Введите ваш API ключ"
              className="w-full px-4 py-2 text-white bg-slate-700 border border-slate-600 rounded-md focus:ring-2 focus:ring-sky-500 focus:outline-none"
              required
            />
            <button type="submit" className="w-full px-4 py-2 font-semibold text-white bg-sky-600 rounded-md hover:bg-sky-700 transition-colors">
              Сохранить и Продолжить
            </button>
          </form>
           <p className="text-xs text-slate-500 text-center pt-4">
              Получить ключ можно на{" "}
              <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-sky-400 hover:underline">
                сайте Google AI Studio
              </a>.
            </p>
        </div>
      );
    };
    
    const ModeSelector = ({ onSelectMode }) => {
        return (
            <div className="w-full max-w-md p-8 space-y-6 bg-slate-800 rounded-lg shadow-xl text-center">
                <h1 className="text-3xl font-bold text-white">Выберите режим</h1>
                <p className="mt-2 text-slate-400">Что вы хотите сделать?</p>
                <div className="flex flex-col md:flex-row gap-4 pt-4">
                    <button onClick={() => onSelectMode('file')} className="flex-1 px-4 py-3 font-semibold text-white bg-sky-600 rounded-md hover:bg-sky-700 transition-colors">
                        Загрузить файл
                    </button>
                    <button onClick={() => onSelectMode('live')} className="flex-1 px-4 py-3 font-semibold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 transition-colors">
                        Использовать микрофон
                    </button>
                </div>
            </div>
        );
    };

    const Loader = ({ text }) => (
      <div className="flex flex-col items-center justify-center space-y-4">
        <div className="loader w-12 h-12 border-4 border-slate-500 rounded-full"></div>
        <p className="text-lg text-slate-300">{text}</p>
      </div>
    );
    
    const TranscriptionResult = ({ text, onReset }) => (
      <div className="w-full max-w-2xl p-6 space-y-4 bg-slate-800 rounded-lg">
          <h2 className="text-2xl font-bold text-white">Результат Транскрибации:</h2>
          <div className="p-4 bg-slate-900 rounded-md max-h-96 overflow-y-auto">
              <p className="text-slate-300 transcription-text">{text || "Нет результата для отображения."}</p>
          </div>
          <button onClick={onReset} className="w-full px-4 py-2 font-semibold text-white bg-sky-600 rounded-md hover:bg-sky-700 transition-colors">
              Начать заново
          </button>
      </div>
    );

    const FileTranscriber = ({ apiKey, onBack }) => {
        const [file, setFile] = useState(null);
        const [loadingStep, setLoadingStep] = useState(''); // 'uploading', 'transcribing'
        const [error, setError] = useState('');
        const [transcription, setTranscription] = useState('');
        const fileInputRef = useRef(null);
        
        const MAX_FILE_SIZE = 200 * 1024 * 1024; // 200 MB

        const handleFileChange = (e) => {
            const selectedFile = e.target.files[0];
            if (selectedFile) {
                if (selectedFile.size > MAX_FILE_SIZE) {
                    setError(`Файл слишком большой. Максимальный размер: ${MAX_FILE_SIZE / 1024 / 1024} МБ.`);
                    setFile(null);
                } else {
                    setFile(selectedFile);
                    setError('');
                }
            }
        };

        const handleTranscribe = async () => {
            if (!file) return;
            setError('');
            setTranscription('');
            
            try {
                setLoadingStep('uploading');
                const uploadedFile = await uploadFileService(apiKey, file);
                
                setLoadingStep('transcribing');
                const resultText = await transcribeAudioFileService(apiKey, uploadedFile);
                
                setTranscription(resultText);
            } catch (err) {
                console.error(err);
                setError("Ошибка транскрибации: " + (err.message || "Неизвестная ошибка. Проверьте ключ API и консоль."));
            } finally {
                setLoadingStep('');
            }
        };
        
        const reset = () => {
            setFile(null);
            setTranscription('');
            setError('');
            setLoadingStep('');
            if(fileInputRef.current) fileInputRef.current.value = "";
        };

        if (transcription) {
            return <TranscriptionResult text={transcription} onReset={reset} />;
        }

        if (loadingStep) {
            const text = loadingStep === 'uploading' ? 'Загрузка файла...' : 'Транскрибация аудио...';
            return <Loader text={text} />;
        }

        return (
            <div className="w-full max-w-md p-8 space-y-6 bg-slate-800 rounded-lg shadow-xl">
                 <button onClick={onBack} className="text-sky-400 hover:underline mb-4">&larr; Назад к выбору режима</button>
                 <h1 className="text-3xl font-bold text-white text-center">Загрузить Файл</h1>
                 <input type="file" accept="audio/*" onChange={handleFileChange} ref={fileInputRef} className="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-sky-100 file:text-sky-700 hover:file:bg-sky-200"/>
                 {error && <p className="text-red-400 text-sm">{error}</p>}
                 <button onClick={handleTranscribe} disabled={!file} className="w-full px-4 py-2 font-semibold text-white bg-sky-600 rounded-md hover:bg-sky-700 transition-colors disabled:bg-slate-600 disabled:cursor-not-allowed">
                     Транскрибировать
                 </button>
            </div>
        );
    };

    const LiveTranscriber = ({ apiKey, onBack }) => {
        const [isRecording, setIsRecording] = useState(false);
        const [finalTranscription, setFinalTranscription] = useState("");
        const [interimTranscription, setInterimTranscription] = useState("");
        const [error, setError] = useState("");
        const sessionRef = useRef(null);
        const streamRef = useRef(null);
        const audioContextRef = useRef(null);
        const scriptProcessorRef = useRef(null);

        const stopRecording = () => {
             if (streamRef.current) {
                streamRef.current.getTracks().forEach(track => track.stop());
                streamRef.current = null;
            }
            if(scriptProcessorRef.current){
                scriptProcessorRef.current.disconnect();
                scriptProcessorRef.current = null;
            }
            if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
                audioContextRef.current.close();
                audioContextRef.current = null;
            }
            if (sessionRef.current) {
                sessionRef.current.close();
                sessionRef.current = null;
            }
            setIsRecording(false);
        };
        
        useEffect(() => {
            return () => stopRecording(); // Cleanup on component unmount
        }, []);
        
        const handleToggleRecording = async () => {
            if (isRecording) {
                stopRecording();
            } else {
                setError("");
                setFinalTranscription("");
                setInterimTranscription("");
                try {
                    const session = await startLiveTranscriptionService(
                        apiKey,
                        (text, isFinal) => {
                            if(isFinal) {
                                setFinalTranscription(prev => prev + interimTranscription + "\n");
                                setInterimTranscription("");
                            } else {
                                setInterimTranscription(text);
                            }
                        },
                        setError
                    );
                    sessionRef.current = session;

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    streamRef.current = stream;
                    
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    const context = new AudioContext({ sampleRate: 16000 });
                    audioContextRef.current = context;

                    const source = context.createMediaStreamSource(stream);
                    const processor = context.createScriptProcessor(4096, 1, 1);
                    scriptProcessorRef.current = processor;

                    processor.onaudioprocess = (e) => {
                        const inputData = e.inputBuffer.getChannelData(0);
                        const l = inputData.length;
                        const int16 = new Int16Array(l);
                        for (let i = 0; i < l; i++) {
                            int16[i] = inputData[i] * 32768;
                        }
                        const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(int16.buffer)));
                        if (sessionRef.current) {
                           sessionRef.current.sendRealtimeInput({ media: { data: base64, mimeType: 'audio/pcm;rate=16000' } });
                        }
                    };

                    source.connect(processor);
                    processor.connect(context.destination);

                    setIsRecording(true);
                } catch (err) {
                    console.error(err);
                    setError("Не удалось получить доступ к микрофону. Проверьте разрешения.");
                }
            }
        };
        
        return (
            <div className="w-full max-w-2xl p-8 space-y-6 bg-slate-800 rounded-lg shadow-xl">
                 <button onClick={onBack} className="text-sky-400 hover:underline mb-4">&larr; Назад к выбору режима</button>
                 <h1 className="text-3xl font-bold text-white text-center">Транскрибация с Микрофона</h1>
                 <div className="p-4 bg-slate-900 rounded-md min-h-[200px] max-h-96 overflow-y-auto">
                     <p className="text-slate-300 transcription-text">{finalTranscription}</p>
                     <p className="text-sky-400 transcription-text">{interimTranscription}</p>
                 </div>
                 {error && <p className="text-red-400 text-sm">{error}</p>}
                 <button onClick={handleToggleRecording} className={`w-full px-4 py-3 font-semibold text-white rounded-md transition-colors ${isRecording ? 'bg-red-600 hover:bg-red-700' : 'bg-indigo-600 hover:bg-indigo-700'}`}>
                     {isRecording ? 'Остановить запись' : 'Начать запись'}
                 </button>
            </div>
        );
    };

    // --- ГЛАВНЫЙ КОМПОНЕНТ ПРИЛОЖЕНИЯ ---

    const App = () => {
      const [apiKey, setApiKey] = useState(localStorage.getItem("geminiApiKey") || "");
      const [mode, setMode] = useState(''); // '', 'file', 'live'

      const handleApiKeySubmit = (key) => {
        localStorage.setItem("geminiApiKey", key);
        setApiKey(key);
      };
      
      const handleBack = () => {
        setMode('');
      };

      if (!apiKey) {
        return <ApiKeyInput onApiKeySubmit={handleApiKeySubmit} />;
      }
      
      if (!mode) {
          return <ModeSelector onSelectMode={setMode} />
      }

      if (mode === 'file') {
          return <FileTranscriber apiKey={apiKey} onBack={handleBack} />;
      }
      
      if (mode === 'live') {
          return <LiveTranscriber apiKey={apiKey} onBack={handleBack} />;
      }

      return null;
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
