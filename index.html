<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Транскрибатор Аудио в реальном времени</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .pulse {
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 1);
            animation: pulse-red 2s infinite;
        }
        @keyframes pulse-red {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }
            70% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 min-h-screen flex items-center justify-center p-4">
    <div id="root" class="w-full max-w-3xl"></div>

    <!-- CDN-версии React и Babel для запуска JSX в браузере -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Основной код приложения -->
    <script type="text/babel" data-type="module">
        // Импортируем Gemini SDK из CDN
        import { GoogleGenAI, Modality } from 'https://aistudiocdn.com/@google/genai@^1.28.0';

        const { useState, useEffect, useRef, StrictMode } = React;

        // --- Gemini Service Logic (из services/geminiService.ts) ---
        
        // Переменные для управления сессией и аудио потоком
        let sessionPromise = null;
        let mediaStream = null;
        let inputAudioContext = null;
        let scriptProcessor = null;
        let mediaStreamSource = null;

        function encode(bytes) {
            let binary = '';
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function createBlob(data) {
            const l = data.length;
            const int16 = new Int16Array(l);
            for (let i = 0; i < l; i++) {
                int16[i] = data[i] * 32768;
            }
            return {
                data: encode(new Uint8Array(int16.buffer)),
                mimeType: 'audio/pcm;rate=16000',
            };
        }

        async function startTranscriptionSession(apiKey, onTranscriptionUpdate, onError) {
            if (sessionPromise) return;

            const ai = new GoogleGenAI({ apiKey });
            let currentInputTranscription = '';

            sessionPromise = ai.live.connect({
                model: 'gemini-2.5-flash-native-audio-preview-09-2025',
                callbacks: {
                    onopen: async () => {
                        try {
                            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            inputAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                            mediaStreamSource = inputAudioContext.createMediaStreamSource(mediaStream);
                            scriptProcessor = inputAudioContext.createScriptProcessor(4096, 1, 1);
                            
                            scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                                const inputData = audioProcessingEvent.inputBuffer.getChannelData(0);
                                const pcmBlob = createBlob(inputData);
                                sessionPromise?.then((session) => session.sendRealtimeInput({ media: pcmBlob }));
                            };
                            
                            mediaStreamSource.connect(scriptProcessor);
                            scriptProcessor.connect(inputAudioContext.destination);
                        } catch (err) {
                            onError(err);
                            stopTranscriptionSession();
                        }
                    },
                    onmessage: (message) => {
                        if (message.serverContent?.inputTranscription) {
                            const text = message.serverContent.inputTranscription.text;
                            currentInputTranscription += text;
                            onTranscriptionUpdate(currentInputTranscription, false);
                        }
                        if (message.serverContent?.turnComplete) {
                            onTranscriptionUpdate(currentInputTranscription, true);
                            currentInputTranscription = '';
                        }
                    },
                    onerror: (e) => {
                        console.error('API Error:', e);
                        onError(new Error('Произошла ошибка API. Проверьте консоль.'));
                        stopTranscriptionSession();
                    },
                    onclose: () => {
                        console.log('Session closed.');
                    },
                },
                config: {
                    responseModalities: [Modality.AUDIO],
                    inputAudioTranscription: {},
                },
            });

            try {
                await sessionPromise;
            } catch (e) {
                onError(e);
                await stopTranscriptionSession();
            }
        }

        async function stopTranscriptionSession() {
            if (sessionPromise) {
                try {
                    const session = await sessionPromise;
                    session.close();
                } catch (e) { console.error('Error closing session:', e); } 
                finally { sessionPromise = null; }
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if(scriptProcessor && mediaStreamSource) {
                scriptProcessor.disconnect();
                mediaStreamSource.disconnect();
                scriptProcessor = null;
                mediaStreamSource = null;
            }
            if (inputAudioContext && inputAudioContext.state !== 'closed') {
                try { await inputAudioContext.close(); } 
                catch(e) { console.error('Error closing audio context:', e); }
                finally { inputAudioContext = null; }
            }
        }

        // --- React Components (из App.tsx) ---

        function ApiKeyManager({ onKeySubmit }) {
            const [apiKey, setApiKey] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (apiKey.trim()) {
                    onKeySubmit(apiKey.trim());
                }
            };

            return (
                <div className="bg-slate-800 p-8 rounded-lg shadow-xl w-full max-w-md mx-auto">
                    <h2 className="text-2xl font-bold text-center text-white mb-6">Введите ваш API ключ Gemini</h2>
                    <p className="text-slate-400 text-center mb-6">
                        Вы можете получить ключ в <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-sky-400 hover:text-sky-300">Google AI Studio</a>.
                    </p>
                    <form onSubmit={handleSubmit}>
                        <input
                            type="password"
                            value={apiKey}
                            onChange={(e) => setApiKey(e.target.value)}
                            placeholder="Ваш API ключ"
                            className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-sky-500"
                        />
                        <button type="submit" className="w-full mt-4 bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-300">
                            Сохранить и начать
                        </button>
                    </form>
                </div>
            );
        }

        function TranscriberApp({ apiKey, onResetKey }) {
            const [isRecording, setIsRecording] = useState(false);
            const [transcription, setTranscription] = useState('');
            const [history, setHistory] = useState([]);
            const [error, setError] = useState(null);
            const transcriptionRef = useRef('');

            const handleTranscriptionUpdate = (text, isFinal) => {
                transcriptionRef.current = text;
                if (isFinal && text.trim()) {
                    setHistory(prev => [...prev, text.trim()]);
                    transcriptionRef.current = '';
                    setTranscription('');
                } else {
                    setTranscription(text);
                }
            };

            const handleError = (err) => {
                setError(`Ошибка: ${err.message}. Проверьте права доступа к микрофону и ваш API ключ.`);
                setIsRecording(false);
                stopTranscriptionSession();
            };

            const toggleRecording = async () => {
                if (isRecording) {
                    await stopTranscriptionSession();
                    setIsRecording(false);
                    if (transcriptionRef.current.trim()) {
                        setHistory(prev => [...prev, transcriptionRef.current.trim()]);
                        transcriptionRef.current = '';
                        setTranscription('');
                    }
                } else {
                    setError(null);
                    setHistory([]);
                    setTranscription('');
                    transcriptionRef.current = '';
                    setIsRecording(true);
                    try {
                        await startTranscriptionSession(apiKey, handleTranscriptionUpdate, handleError);
                    } catch (err) {
                        handleError(err);
                    }
                }
            };

            useEffect(() => {
                return () => { stopTranscriptionSession(); };
            }, []);

            return (
                <div className="bg-slate-800 p-6 sm:p-8 rounded-lg shadow-2xl w-full">
                    <header className="text-center mb-8">
                        <h1 className="text-3xl sm:text-4xl font-bold text-white">Транскрибатор Аудио</h1>
                        <p className="text-slate-400 mt-2">Говорите в микрофон, и ваша речь появится здесь в реальном времени.</p>
                    </header>
                    
                    <div className="flex flex-col items-center justify-center mb-6">
                        <button 
                            onClick={toggleRecording} 
                            className={`flex items-center justify-center w-24 h-24 rounded-full text-white font-semibold shadow-lg transition-all duration-300 transform hover:scale-105 ${isRecording ? 'bg-red-600 pulse' : 'bg-green-600 hover:bg-green-700'}`}
                        >
                          {isRecording ? 'Стоп' : 'Старт'}
                        </button>
                    </div>

                    {error && <p className="text-red-400 bg-red-900/50 p-3 rounded-md text-center mb-4">{error}</p>}
                    
                    <div className="mt-6 bg-slate-900/70 border border-slate-700 rounded-lg p-4 sm:p-6 min-h-[250px] text-lg">
                        <h2 className="text-xl font-semibold text-white mb-4 border-b border-slate-700 pb-2">Результат:</h2>
                        {history.map((line, index) => (
                            <p key={index} className="mb-3 text-slate-300">{line}</p>
                        ))}
                        {transcription && <p className="text-slate-400 italic">{transcription}</p>}
                        {!isRecording && history.length === 0 && transcription === '' && (
                            <p className="text-slate-500">Текст вашей речи появится здесь...</p>
                        )}
                    </div>
                    <div className="text-center mt-6">
                      <button onClick={onResetKey} className="text-sm text-slate-500 hover:text-sky-400">Сменить API ключ</button>
                    </div>
                </div>
            );
        }

        function App() {
            const [apiKey, setApiKey] = useState(() => localStorage.getItem('geminiApiKey'));

            const handleKeySubmit = (key) => {
                localStorage.setItem('geminiApiKey', key);
                setApiKey(key);
            };
            
            const handleResetKey = () => {
                localStorage.removeItem('geminiApiKey');
                setApiKey(null);
            }

            if (!apiKey) {
                return <ApiKeyManager onKeySubmit={handleKeySubmit} />;
            }

            return <TranscriberApp apiKey={apiKey} onResetKey={handleResetKey} />;
        }
        
        // --- Render the App ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
          <StrictMode>
            <App />
          </StrictMode>
        );

    </script>
</body>
</html>
